Всю работу выполняют объекты. Сами по себе классы ничего не делают.

```
class Name {
  public:
     …
  private:
    …
};
```

Открытая часть называется **интерфейсной частью**.
**Приватная часть** - реализующая объекты.

Все методы внутри класса делятся на 4 вида:
- Конструкторы
- Деструкторы
- Селекторы
- Модификаторы

Элементы внутри класса делятся на:
- Обычные
- Статические

Классы могут быть определены внутри других классов

Бывают разные области видимости:
- Файл
- Пространство имён
- Класс

**Класс памяти** - класс для определения объектов классов для использования их извне:
- extern
- static
- auto
- …

`extern int z;` - объявление переменной без выделения памяти (определения). Сама переменная должна храниться в другом месте.

По умолчанию объекты классов являются закрытыми. В структуре все поля являются открытыми.

Любая контекстная функция внутри класса является модификатором.
`void input(int a, int b, int c, float k);` - модифицирует класс.

Функция-селектор не имеет права модифицировать информацию в классе - только читать.
`void print() const;`

`class Pixel` - заголовок класса.

Определение компонентных функций извне:
`void Pixel::input(int a, int b, int c, float k);`

При создании объекта компилятор выделяет память для его элементов ($x, y, color, m, …$), но работать с ними невозможно, т.к. они не проинициализированы. Можно проинициализировать их вызвав заранее заготовленную компонентную функцию, которая проинициализирует переменные. Правильнее всего будет использовать конструктор класса - метод/компонентная функция, который вызывается при инициализации класса и инициализирует необходимые элементы класса. Конструктор имеет такое же имя как и у класса, соответственно их может быть несколько, а значит их можно перегружать. Конструктор не имеет возвращаемого значения. Если в классе есть указатель, то обязательно должен быть копирующий конструктор, иначе может произойти ситуация двойного указания.

**Пример класса** с конструктором/деструктором:
```
class Pixel {
  public:
    Pixel(); // Конструктор по умолчанию
    Pixel(int a, int b, char *c, float k); // Конструктор с формальными параметрами
    Pixel(const Pixel &m); // Копирующий конструктор
    Pixel(int x); // Перегрузка 1
    Pixel(char* c); // Перегрузка 2
}
```

Создание объекта класса с конструктором:
- `Pixel t1;` - вызывается конструктор по умолчанию.
- `Pixel t2(2, 2, "red", 2.3);` - вызывается конструктор с формальными параметрами.
- `Pixel t3(t1);` - вызывается копирующий конструктор.
- `Pixel t4(3);` - вызывается перегруженный конструктор 1.
- `Pixel t5("red");` - вызывается перегруженный конструктор 2.

Конструктор с одним параметром может являться ещё и функцией преобразования типа данных:
- `Pixel(int);      -     int => Pixel`
- `Pixel(char*);    -     char* => Pixel`

При исполнении `int + Pixel` будет вызван конструктор `Pixel(int)`.
При исполнении `"haha" + Pixel` будет вызван конструктор `Pixel(char*)`.

Для уничтожения объекта класса следует использовать деструкторы. Деструктор в классе может быть лишь один. Назначение деструктора - освобождение ранее выделенной памяти. Деструктор имеет имя класса, перед которым дописывается символ "тильда" (~).

**Пример класса** с деструктором:

```
class Pixel {
  public:
    Pixel(); // Конструктор по умолчанию
    int get_x() const; // Функция гетер
    int get_y() const; // Функция гетер
    char* get_color() const; // Функция гетер
    float get_m() const; // Функция гетер
    void set_x(int); // Функция сетер
    void set_y(int); // Функция сетер
    void set_color(char*); // Функция сетер
    void set_m(float); // Функция сетер
    Pixel &copy(const Pixel& m); // Функция копирования (t3.copy(t1);)
    Pixel summa(Pixel a); // Функция суммирования (t2.summa(t1); => t3)
    Pixel* there_I_am() {
        return this; // Указатель на текущий объект класса
    }
    ~Pixel() { // Деструктор
       delete []color;
    }
}
```

При вызове компонентной функции первым её параметром неявно является параметр `this`, т.е. `t1.copy(this, t2);`
this является указателем на текущий объект класса.

Функция в классе => макрокоманда с параметрами
Макрокоманда без параметров: `#define PI 3.1415526;`
Макрокоманда с параметром: `#define cube(x) x*x*x;`

Функции всегда определяются за пределами класса (внутри класса уже не функции)

Если среди объектов класса имеется указатель, необходимо создать собственный конструктор и деструктор, который бы соответственно выделял память для указателя и очищал её. Также в классе обязательно должен быть копирующий конструктор. При копировании указателей из класса в класс, необходимо извлекать из него значение и присваивать новому указателю для избежания двойного указания.

По стилю программирования в классе сначала располагаются конструкторы, затем деструкторы, а после уже всё остальное.

Специальное назначение конструктора с одним параметром: преобразование типа данных в тип класса. Запретить такое поведение можно при помощи слова explicit.

#### Определение компонентных функций

Класс/Определение/Вызовы

```pixel_h
class Pixel {

private:
    int x;
    int y;
    char* color;
    float mas;

public:
    Pixel();
    Pixel(int a, int b, char *c, float m);
    Pixel(const Pixel &m);
    Pixel(int x);
    Pixel(char* c);
    ~Pixel() {
       delete []color;
    }

    int get_x() const;
    int get_y() const;
    char* get_color() const;
    float get_mas() const;
    void set_x(int);
    void set_y(int);
    void set_color(char*);
    void set_mas(float);
    Pixel &copy(const Pixel&);
    Pixel summa(Pixel);
    Pixel* there_I_am() {
        return this;
    }   
};
```
```pixel_cpp
#include "some_class.h"
#include <iostream>

Pixel::Pixel() {
    x = 1;
    y = 1;
    mas = 1.1;
    color = "green";
}

Pixel::Pixel(int a, int b, char *c, float m) {
    x = a;
    y = b;
    mas = m;
    color = new char[strlen(c)+1];
    strcpy(color, c);
}

Pixel::Pixel(const Pixel &m) {
    x = m.x;
    y = m.y;
    mas = m.mas;
    color = new char[strlen(m.color)+1];
    strcpy(color, m.color);
}

Pixel::Pixel(int x) { x = x; }
Pixel::Pixel(char* c) { color = new char[strlen(c)+1]; }
int Pixel::get_x() const { return x; }
char* Pixel::get_color() const { return color; }
float Pixel::get_mas() const { return mas; };
void Pixel::set_x(int a) { x = a; };
void Pixel::set_y(int b) { y = b; };
void Pixel::set_color(char* c) { color = c; };
void Pixel::set_mas(float m) { mas = m; };
```
```code_cpp
#include "some_class.h"
int main() {
    Pixel t1;
    Pixel t1 = Pixel();
    Pixel mt[10]; // Массив пикселей - конструктор по умолчанию
    Pixel t4(3);
    Pixel t5("red");
    Pixel t2(2, 2, "red", 1.1);
    Pixel t3(t2);
    t1.summa(t2); // Второй вариант вызова копирующего конструктора
    t5.get_color();
    t1.set_x(1);
    return 0;
}
```

Копирующий конструктор неявно вызывается когда производится копирование объекта или когда происходит передача объекта в функцию по значению.
При возвращении объекта из функции будет создана точная его копия при помощи копирующего конструктора и возвращена вместо объекта, созданного внутри функции.

Деструктор вызывается в случаях:
- Очистка памяти для локального экземпляра класса внутри функции по выходу из неё
- Очистка памяти для всех подклассов при очистке более общего класса
- При очистке памяти для массива экземпляров
Деструктор быть может вызван явно: `x.~Pixel()`