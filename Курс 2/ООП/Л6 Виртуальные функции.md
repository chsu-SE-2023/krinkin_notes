Позволяет реализовывать полиморфную обработку объектов

==Полиморфная = динамическая==

==Виртуальная функция + открытое наследование==

```
p= &aw;
p->print;

Person *p = &s;
p->print();
```

Если к `print` не дописать ключевое слово `virtual`, то в этом случае `print` выведет информацию о базовом классе, а не о производном.

Свойства и особенности виртуальных функций
1. Нестатическая компонентная функция
2. Виртуальность наследуется
3. Внешний вид один и тот же, смысл разный
4. Деструкторы тоже могут быть виртуальными
5. Если есть виртуальная функция должен быть и виртуальный деструктор

```
class B { // базовый
public:
    int i;
    virtual void print() const {
        std::cout << i << i внутри B << std::endl;
    }
};
class D : public B { // производный
public:
     void print() const {
         std::cout << i << i внутри D << std::endl;
     }
};

int main() {
    B b, *pb = &B;
    D d;
    d.i = d(b.i = 1);
    pb->print(); // выведется для базового класса
    d.print(); // замещения не будет
    pb = &d;
    pb->print(); // замещение будет
    D *pd; pd = &d;
    Pd->print(); // замещения нет
}
```

![[Drawing 2025-04-08 10.37.09.excalidraw]]
```
i = print_i();
pd = &d;
pb = &b;
```
Механизм работает
##### Виртуальные функции и перегрузка

Термины: замещает/скрывает - если не используется с другими

Виртуальные функции необходимы для того, чтобы объявлять их в различных классах, при этом сохраняя тип данных, имя и параметры
```
class B {
public:
    virtual f(int);
    virtual f(float);
};

class D : public B {
    virtual void f(int); // замещение f(int), скрывает f(float
}

main() {
    B b, *pb = &b;
    D d; pd = &d;
    b.f(9);
    d.f(9);
    b.f(9.5);
    d.f(9.5); // произойдёт преобразование
    pb->f(9); // включается замещение
    dp->f(9.5); // B::f(float);
}
```
##### Виртуальные функции без кода

```
virtual int S() = 0;
virtual int P() = 0;
```
^ Чисто виртуальные функции (отложенные методы).

Реализация отложенных методов определяется замещением в каждом из производных объектов.

От класса с такими функциями нельзя создать объекты (только от его производных если в них есть реализация виртуальных (`= 0`) функций)
Он называется `абстрактным базовым классом`

Для того чтобы полиморфно обрабатывать объекты производных классов абстрактного класса можно объявлять указатель на несуществующий объект базового класса.

```
class Shape { // Абстрактный
public:
	void input(int a, int b);
	void print();
	virtual int S() = 0; // Площадь
	virtual int P() = 0; // Периметр
protected:
	int x, y;
};

class Shape1 {
public:
	void input(int a, int b) {};
	void print() {};
	virtual int S() {
		// Реализация для этой фигуры
	};
	virtual int P() {
		// Реализация для этой фигуры
	};
};

int main() {
	Shape s0; // Неверно
	Shape* ps0; // Указатель
	Shape1 s1;
	return 0;
}
```
##### Интерфейсные классы

==Класс интерфейс== - абстрактный класс, содержащий только объявление отложенных методов.

```
class i_Shape { // Интерфейсный
public:
	virtual int S() = 0; // Площадь
	virtual int P() = 0; // Периметр
};
```

Такой класс необходим для указания того, какие функции должны присутствовать в каждом объекте, что объекты могут делать. Эта информация доступна из клиентского кода.

>Представте рекламный щит на заправке, где написано что вы можете не только заправится, но ещё и пройти техобслуживание, просто отдохнуть и так далее

От класса интерфейса должен быть создан базовый класс

```
class Shape: public i_Shape { // Абстрактный
public:
	void input(int a, int b);
	void print();
	virtual int S() = 0; // Площадь
	virtual int P() = 0; // Периметр
protected:
	int x, y;
};
```

##### Наследование и шаблоны

![[Drawing 2025-04-08 11.16.14.excalidraw]]

```
template <class T>
class Stud {
public:
	...
protected:
	int a;
	T b;
};

template <class T> // T = int
class Asp: public Stud<T> {
public:
	...
protected:
	T d;
};
```
