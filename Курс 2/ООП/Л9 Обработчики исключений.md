==Исключительные ситуации== - нештатные ситуации работы программы. Обработка этих ситуаций есть борьба за стабильность ПО.
Под надёжностью программного обеспечения - относительно длительное получение бессбойных результатов.

Инструменты для обработки исключений:
1. `assert` (assertion - проверка утверждений) - используется для организации контрольных точек;
2. `signal.h` - библиотека сигналов, которая позволяет бороться с внештатными ситуациями путём получения базовых исключений;
3. `try` `throw` `catch`
Эти инструменты следует использовать только для обработки возможных внештатных ситуаций.
##### assert

`void assert(bool выражение)` - представляет собой макрокоманду с параметрами.

Вся программа - последовательность операторов. Перед тем оператором или вызовом, в котором может произойти внештатная ситуация устанавливается контрольная точка (проверка предусловия). Также контрольная точка может быть установлена после оператора или вызова (проверка постусловия). 

==Пример==:
```
class Vect {
private:
	int *p;
	int size;
public:
	Vect(int);
}

Vect::Vect(int n) {
	size = n;
	assert(size > 0);
	p = new int[size];
	assert(p != nullptr);
}
```
Контрольные точки позволяют вызвать останов программы при неверных данных, но при этом не даёт возможности возобновить программу. Также вызов этой команды не предполагает вывод какого-либо сообщения об ошибке.
##### signal.h

`#include <signal.h>`
Библиотека предоставляет стандартный интерфейс для простой обработки исключений, определяемых самой системой исключений. Исключения обрабатываются асинхронно.

> `#define` - определение макрокоманд. Пример: `#define PI 3.1415926`, `#define cube(x) x*x*x`. Аналогом макрокоманд является `inline` функции.

В библиотеке есть набор макрокоманд:
- `#define SIGINT 2` - сигнал прерывания;
- `#define SIGFPE 8` - сигнал исключения с плавающей точкой;
- `#define SIGBRT 22` - сигнал аварийного завершения программы;
- ...
набор функций:
- `raise(сигнал)` - функция для вызова ручного вызова сигнала;
- `signal(сигнал, своя функция)` - связывает конкретный сигнал с функцией для его обработки.

##### try throw catch

Пробный блок:
```
// обычный ход программы
try {
	// операторы с возможной внештатной ситуацией
}
```

`throw(выражение исключения (+тип) (временное статическое выражение))` - "запустить" обработчик исключений (вызвать исключение).

`catch(тип исключения)` - функция без возвращаемого типа с параметром типа перехватываемого исключения. Эта функция предназначена для борьбы с внештатной ситуацией (выполнится как только блоком try будет поймано исключение).

==Пример (бессмысленный)==:
```
int x, y;
try {
	x = a + b;
	y = a - b;
	if (x > y) throw(x+y);
	...
} catch (int) {
	...
}
```

==Пример (сос мыслом)==:
``` vector_h
class Vect { // Контейнер на основе динамического списка
private:
	float* p;
	int k;
public:
	Vect(int size);
}
```
``` vector_cpp
Vect::Vect(int size) : k(n) {
	if (n < 1) throw(n); // Предусловие
	p = new float[n];
	if (p == 0) throw("Памяти нет"); // Постусловие (если в куче нет места)
}
```

> "Класс, класс и все компонентные функции" - Ершов Е. В.

``` Source_cpp

void f() {
	int i = 10, j = -10;
	try {
		Vect v1(i);
		Vect v2(j); // Вызов исключения
	} catch (int x) {
		Vect v1(-x); // Обработка предусловия
		Vect v2(-x);
	} catch (const char* error) {
		std::cout << error; // Обработка постусловия
	}
}

int main() {
	...
	f();
	...
}
```

#### Запуск и перезапуск исключений

```
void f1() {
	int m = 5;
	...
	f2();
	...
}

void f2() {
	int d = 11;
	if (?) throw(d); // Временный статический объект int = 11
	...
}

main() {
	int x = 1, y = 2, z = 3;
	try {
		int a = 1, b = 2, c = 3;
		if (?) 
			try { // Вложенный блок try
				int k = 1, n = 2, l = 3;
				f1();
			} catch (int n) { // int 11
				...
				throw;
			} catch (тип) {
				...
			}
	} catch (int m) {
		...
	} catch (тип) {
		...
	}
}
```

При вызове в `throw()` из `f2()` происходит раскручивание стека и все инициализированные ранее переменные исчезают, управление передаёся в блок catch, в котором доступно лишь выражение исключения.

Команда `throw` без параметров перезапускает последний вызванный обработчик. В этом случае в примере будет работать `catch (int m)` для первого `try`.

#### Вложенные блоки try

```
void f() {
	try {
		...
		try {
			...
			try { // Вложенные блоки
				throw(тип);
			} catch() {
				...
			}
		} catch() {
			...
		}
	} catch () {
		...
	} catch() {
		...
	}
}
```

Если внутренний блок `try` вызвал необработанное исключение, будет использован внешний обработчик `try`. 
Если у `try` нет `catch`, будет вызван системный обработчик `unexpected`.

#### Функции обработчики

Функции обработчики - функции, которые имеют (кого?).

- `catch(тип) {}`
- `catch(...) {}` - с переменным числом параметром (любой тип) %% "..." - эллипсис%%

Последовательность обработчиков имеет значение.