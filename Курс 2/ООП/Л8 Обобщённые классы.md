##### До шаблонов:

```
class Vector {
public:
	Vector();
	Vector(void *d, int n);
	Vector(const Vector &m);
	~Vector();
	void print() const;
	void input(void *d, int n);
	void* find(void *d);
protected:
	void* p; // Обобщённое объявление указателя (массив void)
	int k;
};

// Класс для объекта-функции
class Vector_str: private Vector {
public:
	Vector_str() {};
	void print() {Vector::print()};
	void input(char *d, int n) {Vector::input(d, n)};
	char* find(char *d) {
		return static_cast<char*>(Vector::find(d));
	};
}
```

`static_cast` - принудительное преобразование (в примере void* -> char*)

==Объект-функция== - объект, созданный из класса, который содержит в себе только функции, вызывающие функции другого класса.

Класс выше можно переделать в шаблон:
```
template <class T>
class Vector_str: private Vector {
public:
	Vector_str() {};
	void print() {Vector::print()};
	void input(T *d, int n) {Vector::input(d, n)};
	T* find(char *d) {
		return static_cast<char*>(Vector::find(d));
	};
}
```
При этом базовый класс должен остаться обобщённым

Обобщённый класс нужно создать в курсовой (контейнер в котором будет указатель на класс-интерфейс).
##### Идентификация типа на этапе выполнения - RTTI (Runtime type indentificaton)

- В старых системах можно просто преобразовать тип переменной  - `(int)x`. 
- В C++ для этого предусмотрен оператор `dynamic_cast<тип> p`
- В C++ существует структуризированный оператор `type_info`

В C++ в классе можно определять функцию внутри функции. В C так сделать нельзя.
##### Тип данных "объединение" (union)

>Объект == Структурная переменная

```
union type { // union вместо class/struct
	int x;
	float y;
	char z;
};
```
Если бы это была структурная переменная (struct/class) - на тип, описанный выше будет выделено 7 байт. С union будет выделено 4 байта и при этом можно будет хранить в памяти значение только одного поля. Это нужно в ситуациях когда необходимо экономить память, но при этом не требуется использовать все поля класса сразу. Также этот инструмент может реализовать шаблон - использование полей разных типов у одного и того же объекта.
Объединения также могут иметь конструкторы и деструкторы, но не может быть виртуальных функций. Элемент объединения не может требовать конструктор или деструктор.