==Полиморфизм== - способность одного и того же действия принимать разные формы в зависимости от разных типов данных.
###### Для функций

Перегруженными могут быть как внешние, так и компонентные функции.

Выбор той или иной перегруженной функции при вызове определяется компилятором на основе алгоритма распознавания сигнатуры параметров. Работа алгоритма:
- проверяется количество параметров,
- проверяется соответствие типов,
- приоритет имеет строгое соответствие типов,
- если типы не совпадают производится попытка стандартного повышения типа,
- в другом случае выполняется стандартное преобразование типа данных (для указателей),
- применяется преобразование типов данных, определённое пользователем,
- существует возможность использовать переменное количество параметров при помощи оператора … (эллипсис).
Список параметров = интерфейс функции
##### Перегрузка преобразований типов данных

```
char c;
int I;
float d;
Pixel t;

d = c + 1;    // float = char (повышается) + int = int (повышается)
c = i + d;     // char = int (повышается) + float = float (понижается)
d = c + i + t;     // float = char (повышается) + int + Pixel = int (преобразует) + Pixel
t = d + c + t;    // Pixel = float + char (повышается) + Pixel = float (преобразует) + Pixel
```

Для понижения класса необходимо иметь компонентную (нестатическую) функцию:
`operator float();`
##### Перегрузка операторов

Для сложения `Pixel + Pixel` можно вызвать функцию `Pixel summa(Pixel)`.
Для того чтобы можно было использовать оператор присваивания, необходимо добавить компонентную функцию:
```
Pixel operator+ (Pixel);
Pixel Pixel::operatop+ (Pixel) {…}
(t1.operator+(t2;))
```

Если в классе есть копирующий конструктор, то обязательно должна быть функция, перегружающая оператор присваивания:
```
Pixel& operator= (const Pixel&);
Pixel& Pixel::operator= (const Pixel&) {…}
(t1.operator=(t2;))
```

Перегрузка инкремента и декремента
```
Pixel& operator++();

Pixel& operator++(int);
```
###### Оператор принудительного преобразования типов

`static_cast<type> value;`

- Операторы можно перегружать не только внешними, но и компонентными функциями.
- Операторы `= [] () ->` могут быть перегружены только нестатическими компонентными функциями.
- Операторы `new delete` перегружаются только статическими компонентными функциями.
- Операторы `:: sizeof ?: . .*` Перегружать нельзя
##### Дружественная функция (внешняя)

```
friend Pixel operator+(Pixel a, Pixel b);
(operator+(t1, t2);)
```

Объявление дружественной функции может быть в любой его части.
Наличие дружественных функций позволяет обойти скрытие элементов класса:

```
class A {
public:
friend void f(A a, B b, C c);
void f_A();
…
};

class B {
public:
friend void f(A a, B b, C c);
void f_B();
…
};

class C {
public:
friend void f(A a, B b, C c);
void f_C();
…
};

f(a, b, c); // C дружественной
a.get_x(); b.get_y(); c.get_c(); /// Без дружественной (медленно)
```

Компонентная функция неявно принимает первый параметр this, дружественная функция принимает все параметры явно.

%%Вопрос: чем перегрузка оператора через внешнюю дружественную функцию выигрышнее чем через компонентную.%%

Вместо
```
void f(a, b, c, d, …) {
  x.get_1_1();
  x.get_1_2();
  x.get_1_3();
  y.get_2_1();
  y.get_2_2();
  y.get_2_3();
  z.get_3_1();
  z.get_3_2();
  z.get_3_3();
  …
}
```

Следует использовать дружественные функции, поскольку реализация получения данных выше слишком медленная.

- Дружественными могут быть как внешними функциями, так и компонентными функциями.
- Дружественным можно сделать и другой класс целиком.

##### Перегрузка бинарных операторов при помощи дружественных функций

При перегрузке не должно быть двух функций, реализующий один оператор

```
class Pixel {
public:
  Pixel operator+(Pixel b); // Комп. функция
  friend Pixel operator+(Pixel a, Pixel b); // Дружественная функция
}
```

В коде выше возникнет синтаксическая ошибка.

Перегрузка операторов позволяет реализовать одну и ту же операцию для различных типов классов всего один раз. Также обеспечивается временный доступ к закрытым данным классов, что может потребоваться при отладке.

``` vector_h
class Vector {
private:
  int *p;                
  int k;
public:
  int get(int i);
}
```
```vector_cpp
int Vector::get(int i) {
  return p[i];
}
```
```code_cpp
Vector v1, v2(mas, 10), v3(v2);  
v1.get(3);  
v2.get(9);
```

В классе выше следует реализовать перегрузку оператора `[]`:
```
int& Vector::operator[] (int i) {
   return p[i];
}
```
При `… = v3[4]` возвращаемый тип оператора `[]` не должен быть ссылочным.
При `v3[4] = …` возвращаемый тип оператора `[]` должен быть ссылочным.

```matrix_cpp
class Matrix {
private:
  float **p;
  int n, m;
public:
  float get(int i, int j);
}
```
```matrix_cpp
float Matrix::get(int i, int j) {
  return p[i][j];
}
```
```code_cpp
Matrix m1, m2(mass, 10, 20), m3(m2);  
m1.get(5, 5);  
m2.get(3, 4);
```

В классе выше следует реализовать перегрузку оператора `()`:
```
float& Vector::operator() (int i, int j) {
   return p[i][j];
}
```

Перегрузка оператора `[][]` - не предусмотрена.

Реализация контейнеров выше предусматривает лишь один тип хранимых данных - int ли float. Для того чтобы это исправить следует превратить его в класс-шаблон.
```
B b1, b2, b3;
A a1, a2, a3;
b1.f_b();
a1.f_a();
b1->f_A(); // Перегруженный оператор -> вызывает компонентную функцию будто b1 - указатель. Это необходимо для агрегации
```
##### Перегрузка операторов new, delete, <<, >>

%%…%%
##### Статические компонентные данные

Распределяются всем объектам класса одинаково
- Объявление - static int d;
- Определение и инициализация - int Pixel::d = 1;

Статический элемент данных может существовать и без создания объекта, память выделяется в статической области при инициализации элемента.
```
t1.d = 2;
t2.d = 3;
t3.d = 4;
Pixel::d = 5;
```
Изменение статической влечёт за собой изменение её значения во всех объектах.

Для работы с такими данными предназначены `статические компонентные функции`

```
static float mas;
static void set_mas(float k);
static float get_mas() const;
```
Эти подпрограммы существуют также как и другие статические элементы уже без создания объекта.
Вызов статической функции - `Pixel::set_mas(3.4);`
##### Объекты-константы

`const Pixel t4;`

Такой объект после создания не может быть изменён
Для изменения в таких объектах некоторых данных следует использовать `mutable`
##### Параметрический полиморфизм

Относительный - ==Шаблоны классов, шаблоны функций==

Для классов с разными типами данных можно создать два разных класса, но можно создать класс-шаблон:
```pixel_h
template <class T>
class Pixel {
Public:
  T get_x() const;
  T get_y() const;
private:
  T x, y;
  char *color;
  float mas;
}
```
``` pixel_cpp
template <class T>
T Pixel<T>::get_x() const {
  return x;
};
```
``` code_cpp
Pixel<int> t1, t2(2, 3, "red", 4.5);
```

При создании происходит инстанцирование - замена параметра шаблона на конкретный тип данных.

`Pixel<int>` и `Pixel<float>` - разные типы данных, для которых в машинном коде будет выделено отдельное место.

Шаблонные классы могут иметь дружественные функции, но при этом они не могут использовать параметры шаблона.

Существует возможность определить более обширный шаблонный класс:
```pixel_h
template <class T1, T2>
class Pixel {
Public:
  T1 get_x() const;
  T2 get_y() const;
private:
  T1 x;
  T2 y;
  char *color;
  float mas;
}
```
```pixel_cpp
template <class T1, T2>
T1 Pixel<T1, T2>::get_x() const {
  return x;
};
```
```code_cpp
Pixel<int, float> t1, t2(2, 3.5, "red", 4.5);
```

Шаблонными могут быть и внешние функции:

```
template <class T>
void swap(T& x, T& y) {
  T temp;
  temp = x;
  x = y;
  y = temp;
}
```

В этом примере соответствие типов должно быть обязательно, но шаблонные функции можно перегружать, при этом компилятор всегда отдаёт приоритет для нешаблонных функций.