**Дерево** - совокупность элементов называемых узлами, один из которых определён как корень, и родительских отношений, определяющих иерархическую структуру дерева.

#### Дерево (рекуррентное определение)
1. Один узел является деревом. Этот же узел является его корнем.
2. Пусть $n$ - узел, а $T1, T2, …, Tk$ - деревья с корнями $n1, n2, …, nk$ соответственно, можно построить новое дерево, сделав узел n родительским для узлов $n1, n2, …, nk$. В этом дереве $n$ - корень, $T1, T2, …, Tk$ - поддеревья этого корня, узлы $n1, n2, nk$ - прямые потомки (сыновья) узла $n$.

![[Drawing 2025-04-08 01.38.21.excalidraw]]
Корень дерева - A
Листья дерева - E, F, J, K, H, I
Высота дерева - 3

#### Дерево (определение)
Путём из узла в n1 в узел nk называется последовательность узлов, где узел ni является родительским для узла n1 для всех i >= 1 и меньше k. Длиной пути называется число количества узлов составляющих этот путь. Если существует путь из узла a в b, то a предок узла b, а b - потомок узла a. Считается что любой узел является предком и потомком самому себе. Таким образом корень дерева - это узел, не имеющий других предков, кроме самого себя. Узел, не имеющий других потомков, кроме себя, называется листом или терминальным узлом дерева. Высотой узла дерева называется длина самого длинного пути из этого узла до одного из листьев. Высота дерева совпадает с высотой его корня.  Глубиной узла называется длина пути от корня до этого узла.

Деревья можно обходить различными способами: каждый обход это способ упорядочения узлов дерева по некоторому признаку, обычно выделяют три способа обхода деревьев: прямой, обратный, симметричный.

1. Если дерево T является нулевым деревом, то в список обхода заносится пустая запись.
2. Если дерево T состоит из одного узла, то в список обхода заносится этот узел.
3. Пусть T - дерево с корнем n и поддеревьями T1, T2, …, Tk, тогда для разных способов обхода имеем.
	1. При прямом обходе сначала посещается n, далее поддеревья T1, T2, …, Tk также в прямом порядке.  
	   Прямой для дерева выше - A -> B -> E -> F -> C -> G -> J -> K -> D -> H -> I
	2. При обратном обходе в обратном порядке посещается поддерево T1, далее T2, …, Tk, последним посещается узел n.  
	   Обратный для дерева выше - E -> F -> B -> J -> K -> G -> C -> H -> I -> D -> A
	3. При симметричном обходе сначала в симметричном порядке посещается поддерево T1, затем корень n, далее поддеревья T2, T3, …, Tk также в симметричном порядке.  
	   Симметричный для дерева выше - E -> B -> F -> A -> C -> J -> G -> J -> K -> H -> D -> I

Отдельное место занимают деревья, каждый узел которых может иметь не более двух прямых потомков. Такие деревья называются **бинарными** ~~(b-дерево)~~.

#### Способы представления бинарных деревьев

##### С помощью одномерного массива

![[Drawing 2025-04-08 01.44.37.excalidraw]]

Если считать что массив нумеруется с нуля, то у $i$ элемента левый потомок будет под индексом $2*i+1$, а правый - $2*i+2$.

1. С помощью динамической структуры.  
    Каждый узел дерева состоит как минимум из трёх полей: поле данных и указатели на поддеревья.

Бинарное дерево называется **сбалансированным**, если высоты левого и правого поддеревьев каждого узла дерева отличаются друг от друга не более чем на единицу.

Бинарное дерево **идеально сбалансированное** если разность высот поддеревьев каждого из узлов равна нулю.
##### Пример реализации бинарного дерева

```
#include <iostream>

struct Node {
    int data;
    Node *left, *right;
};

void add(Node*& node, int value) {
    if (node == NULL) {
        node = new Node;
        node->data = value;
        node->left = NULL;
        node->right = NULL;
    }
}

void print(Node* node) { // Прямой обход
    if (node != NULL) {
        std::cout << node->data << " ";
        print(node->left);
        print(node->right);
    }
}

void print_sim(Node* node) { // Симметричный обход
    if (node != NULL) {
        print(node->left);
        std::cout << node->data << " ";
        print(node->right);
    }
}

void print_rev(Node* node) { // Обратный обход
    if (node != NULL) {
        print(node->left);
        print(node->right);
        std::cout << node->data << " ";
    }
}

int main() {
    Node* root = NULL;
    add(root, 5);
    add(root->left, 6);
    add(root->right, 2);
    add(root->right->left, 3);
    add(root->right->right, 4);
    add(root->right->right->left, 7);
    print(root);
    return 0;
}
```

#### Дерево Хаффмана
%%По его работе см. Курс 1/Теория Автоматов%%

```
#include <iostream>

class HaffmanTree {
private:
    struct Node {
        char c;
        int p;
        Node *left, *right, *parent;
    };

    Node *trees[256], *symbols[256];
    int count;

public:

    HaffmanTree(int col) {
        count = col;
    }

    void readInfo() {
        for (int i = 0; i < count; i++) {
            trees[i] = new Node;
            symbols[i] = trees[i];
            std::cout << "Enter symbol: "; std::cin >> trees[i]->c;
            std::cout << "Enter frequiency: "; std::cin >> trees[i]->p;
            trees[i]->left = NULL;
            trees[i]->right = NULL;
            trees[i]->parent = NULL;
        }
    }

    void makeTree(int col) {
        if (col > 1) {
            int min1 = 2000000000, min2 = 2000000000;
            int n1 = 0, n2 = 0;
            for (int i = 0; i < count; i++) {
                if (trees[i] != NULL && trees[i]->p < min1)
                    n1 = i; min1 = trees[i]->p;
            }
            for (int i = 0; i < count; i++) {
                if (trees[i] != NULL && trees[i]->p < min2 && i != n1)
                    n2 = i; min2 = trees[i]->p;
            }
            Node* tmp = new Node;
            tmp->left = trees[n1]; tmp->right = trees[n2];
            tmp->p = trees[n1]->p + trees[n2]->p;
            tmp->parent = NULL;
            trees[n1]->parent = tmp; trees[n2]->parent = tmp;
            trees[n1] = tmp; trees[n2] = NULL;
            makeTree(col - 1);
        }
    }
};

int main() {
    HaffmanTree hf(5);
    hf.readInfo();
    return 0;
}
```