Литература:

1. Ахо Альфред В., Хопкрофт Джон Э., … - Структуры и алгоритмы.
2. Кнут Д. Э. Искусство программирования (в 3-х томах)
3. Никлаус Вирт Алгоритмы и структуры данных
4. Клейнберг Джон, Т. Ева. Алгоритмы: разработка и применение

Схема процесса создания программы для решения прикладной задачи:
![[Drawing 2025-04-08 01.19.32.excalidraw]]

1. На первом этапе задача описывается с помощью некоторого математического аппарата, то есть создаётся математическая модель. На базе этой модели определяется неформальный алгоритм решения задач.
2. Математическая модель преобразуется в абстрактный тип данных, АТД - сама модель + операции, определённые для этой модели. Теперь используя эти операции описываем программу на псевдо языке.
3. Реализуем АТД с помощью конкретных структур данных языка программирования (массив, список, стек, …) и используя эти структуры пишем программу. Вид программы будет существенно зависеть тех структур данных, которые были выбраны.

**Пример**:
Дана плоская географическая карта. Раскрасить государства разными цветами так, чтобы никакие два соседних (имеющих общую границу) не были раскрашены в один цвет. По возможности использовать небольшое кол-во цветов (или минимальное).

1. Математическая модель - граф. Вершины графа - государства. Рёбра графа - наличие границы. Алгоритм: текущее государство будем раскрашивать в первый подходящий цвет не занятый цвет. Цвет считается не занятым если в него не окрашено ни одно соседнее государство (жадный алгоритм).
2. АТД - граф, с определёнными на нём операциями: нахождение вершин, смежную с i, определение цвета вершины, раскраска вершины цветом color и т.д.  
```
    цикл i=1 to количество вершин {  
      обнулить флаги цветов;  
      цикл j=1 to количество вершин {    
        если (вершина i смежная с i и j цветом color_k)                 установить флаг цвета color_k;    
        найти первый свободный цвет color_s;    
        раскрасить i цветом color_s;  
      }  
    }
```
3. Структуры - двумерный и одномерный массивы.  
    Программа на ЯП.  
     
#### Stack

Абстрактный тип данных, который представляет собой последовательность элементов, доступ к которым производится по правилу LIFO.

Операции:
- nullStack - обнуление стека;
- empty - проверка на пустоту;
- push - добавление в стек;
- pop - удаление элементов из стека.
###### Реализация стека

```
struct Stack 1 {
  int top;
  int *data;
};

void initStack (Stack1 &st, int capacity) {
  st.data = new int[capacity];
  st.top = -1;
}

void push (Stack1 &st, int value) {
  st.data[++st.top] = value;
}

int pop(Stack1 &st) {
  return st.data[st.top--];
}

void nullStack (Stack1 &st) {
  st.top = -1;
}

bool empty (Stack1 &st) {
  return st.top == -1;
}
```

Реализация стека массивом имеет тот недостаток, что размер стека ограничен размером массива. Для того чтобы сделать стек "неограниченного" размера можно использовать динамический линейный список. Каждый элемент такого списка представляет собой структуру, состоящую как минимум из двух полей: поле данных и указателя на такую же структуру - следующий элемент динамического списка.

![[Drawing 2025-04-08 01.29.15.excalidraw]]
![[Drawing 2025-04-08 01.30.35.excalidraw]]
```
struct Node {
  int data;
  Node *next;
}

void initStack(Node *&top) {
  top=NULL
}

void push(Node *&top, int value) {
  Node *tmp = new Node;
  tmp->next = top;
  top = tmp;
  top->data = value;
}

int pop(Node *&top) {
  Node *tmp = top;
  int d = top->data;
  top = top->data;
  delete(tmp);
  return d;
}

bool empty(Node *&top) {
  return top==NULL;
}

void nullStack(Node *&top) {
  Node *tmp;
  while (!empty(top)) {
    tmp = top;
    top = top->next;
    delete(tmp);
  }
}
```

#### Очередь - Queue

Последовательность объектов/данных, доступ к которой производится по принципу FIFO (First In - First Out).

##### Операции
- nullQueue - обнуление очереди
- empty - проверка очереди на пустоту
- add (qnqueue) - добавление элемента в очередь
- del (dequeue) - удаление элемента в очереди

##### Реализация очереди динамическим списком

```
class Queue {
private:
    struct Node {
        int data;
        Node *next;
    };
    Node *head, *tail;
    
public: 
    Queue() {
        head = 0;
        tail = 0;
    } 

    bool empty() {
        return head= 0;
    }

    void add(int value) {
        if (empty()) {
            head = new Node;
            head->data = value;
            head->next = 0;
            tail = head;
        }
        else {
            tail->next = new Node;
            tail = tail->next;
            tail->data = value;
            tail->next = 0;
        }
    }

    int del() {
        if (empty()) {
            cout << "Queue is empty" << endl;
            return 0;
        } else {
            int d = head->data;
            Node *tmp = head;
            head = head->next;
            delete(tmp);
            return d;
        }
    }

    void nullQueue() {
        Node *tmp;
        while (!empty()) {
            tmp = head;
            head = head->next;
            delete(tmp);
        }
    }
};
```

##### Реализация очереди массивом

При реализации массивом возникает неприятность: пусть в массиве n элементов, тогда когда индекс хвоста достигнет значения n-1 напрашивается вывод что очередь переполнена, но к этому времени из головы очереди могут выйти несколько элементов и в начале массива окажется свободное место. Можно каждый раз при достижении хвостом конца массива сдвигать очередь в начало, если там есть свободное место, но при больших размерах очереди это трудозатратно. В связи с этим было предложено считать массив закольцованным: когда за последним n-1 элементом следует нулевой. Номер следующего за i-ым элементом будем вычислять не обычной операцией ++, а по формуле (i + 1) % n. При такой реализации возникает ещё одна проблема: элементы можно добавлять в очередь пока индекс хвоста не будет на 1 меньше индекса головы (не упрётся в голову). С другой стороны при удалении элемента мы возвращаем значение из головы и сдвигаем индекс головы на 1 ближе к хвосту, когда удалим все элементы за хвостом снова будет следовать голова. => Не отличить пустую или переполненную очередь. Было предложено считать очередь пустой когда за хвостом следует голова и переполненной когда между хвостом и головой один свободный элемент.

```
struct Queue1 {
  int head, tail, size;
  int *data;
}

void nullQueue(Queue1 &q) {
  q.head = 0
  q.tail = q.size-1;
}

void initQueue(Queue1 &q, int capacity) {
  q.size = capacity+1;
  q.data = new int[q.size];
  nullQueue(q);
}

int next(Queue1 &q, int n) {
  return (n+1)%q.size;
}

bool empty(Queue1 &q) {
  return next(q, q.tail) == q.head;
}

void add(Queue1 &q, int value) {
  if (next(q.next(q, q.tail)) == q.head)
    cout << "Queue overflow" << endl;
  else
  {
     q.tail = next(q, q.tail);
     q.data[q.tail] = value;
  }
}

int del(Queue1 &q) {
  if (empty(q)) {
    cout << "Queue is empty" << endl;
    return 0;
  else {
    int d = q.data[q.head];
    q.head = next(q, q.head);
    return d;
  }
}
```

#### Дек - deq (Double ended queue)

Это абстрактный тип данных, представляющий собой последовательность добавление и удаление элементов которой возможно с обеих сторон.