Наиболее часто выполняемая задача в информационных системах - задача поиска данных. Она производится настолько часто, что даже O(n) - слишком большая.

##### Прямой поиск
Элементы последовательности просматриваются друг за другом пока не найден искомый ключ или  не просмотрена вся последовательность и ключ не найден.
В среднем при поиске одного значения из n элементов необходимо просмотреть половину последовательности - O(n).

(Находим конкретный индекc)
```
int StraightSearch(int* a, int n, int key) {
    int i = 0;
    while (i < n && a[i] != key) i++;
    if (i == n) return -1;
    else return i;
}
```

Можно заметить что в цикле while непосредственно к поиску имеет отношение лишь второе условие. Первое нужно чтобы не выйти за границы памяти. Алгоритм улучшается если увеличить массив на один элемент и перед поиском в последнем (под n) помещать искомый ключ.

```
int StraightSearch(int* a, int n, int key) {
    int i = 0;
    a[n] = key;
    while (a[i] != key) i++;
    if (i == n) return -1;
    else return i;
}
```

##### Бинарный поиск

Перед осуществлением процедуры поиска последовательность должна быть отсортирована. В ней выбираются средние элементы (`[n/2]`) и если это искомый элемент - поиск завершается. В противном случае сравниваются ключи со средним элементом: если значение меньше ключа - двигаемся влево, иначе вправо.
Сложность - $O(log2(n))$ (без учёта сортировки).

```
int BinarySearch(int* a, int n, int key) {
    int left = 0, right = n-1, i = (???+n)/2;
    while (left <= right && a[i] != key) {
        if (key < a[i]) right = i - 1;
        if (key > a[i]) left = i + 1;
        i = (left + right)/2;
    }
    if (left > right) return -1;
    else return i;
}
```

##### Деревья поиска

Будем помещать элементы последовательности в бинарное дерево:
- 1-ый - корень
- Каждый следующий по принципу: если элемент меньше корня записывается влево, больше корня - вправо. И так рекурсивно

![[Drawing 2025-04-08 02.19.43.excalidraw]]
```
#include <iostream>

struct Node{
	int data;
	Node* left, * right;
};

void formTree(Node*& root, int key) {
	if (root == NULL) {
		root = new Node;
		root->data = key;
		root->left = NULL;
		root->right = NULL;
	} else if (key < root->data)
		formTree(root->left, key);
	else if (key > root->data)
		formTree(root->left, key);
}

void printTree(Node*& root) {
	if (root != NULL) {
		printTree(root->left);
		std::cout << root->data << " ";
		printTree(root->right);
	}
}

int main() {
    const int n = 10;
	int a[n] = { 6, 3, 19, 1, 5, 2, 8, 9, 10, 7};
	Node* root = NULL;
	for (int i = 0; i < n; i++)
		formTree(root, a[i]);
	printTree(root);
	return 0;
}
```

Поиск элемента по такому дереву производится сравнением ключа, который ищем с данными в корне. Если ключ и данные совпадают - элемент найден. Если ключ меньше продолжим рекурсивно поиск в левом поддереве, если больше - в правом. В лучшем случае (дерево - сбалансированное) сложность такого поиска — $O(log2n)$. Однако в худшем случае дерево может выродится в линейный список и сложность поиска составит $O(n)$. 

> "Для вас лучше подходит невербальное общение" - Пышницкий К. М.

Дерево поиска является уже отсортированным деревом. Данные из узлов сортируются по возрастанию при симметричном обходе дерева.

Пример:
Пусть имеется текстовый файл в каждой строке которого записано некоторое слово. Используя дерево поиска найти частоту вхождения каждого слова в файл и вывести слова с их частотами в алфавитном порядке.
```
#include <iostream>
#include <fstream>

struct Node{
	std::string data;
	int k;
	Node* left, * right;
};

void formTree(Node*& root, std::string& key) {
	if (root == NULL) {
		root = new Node;
		root->data = key;
		root->k = 1;
		root->left = NULL;
		root->right = NULL;
	} else if (key < root->data)
		formTree(root->left, key);
	else if (key > root->data)
		formTree(root->left, key);
	else root->k++;
}

void printTree(Node*& root) {
	if (root != NULL) {
		printTree(root->left);
		std::cout << root->data << " - " << root->k << std::endl;
		printTree(root->right);
	}
}

int main() {
	const int n = 10;
	Node* root = NULL;
	std::ifstream f("input.txt");
	std::string word;
	while (!f.eof()) {
		f >> word;
		formTree(root, word);
	}
	printTree(root);
	return 0;
}
```

##### АВЛ - деревья

В 1962 году советские математики Адельсон-Вельский и Ландис предложили способ поддерживать дерево поиска всегда в сбалансированном виде, а значит организовывать поиск гарантировано со сложностью $O(log2n)$. Для своей реализации метод требует лишь дополнительных двух бит %%(байт при реализации)%% на каждый узел . Для каждого узла дерева определим фактор сбалансированности:
- $+1$ - правое поддерево на единицу выше левого, 
- $-1$ - левое на единицу больше правого, 
- $0$ - высоты левого и правого поддеревьев одинаковы.

![[Drawing 2025-04-08 09.41.26.excalidraw]]

Это сбалансированное дерево имеет высоту $4$ и $8$ внутренних узлов ($A,B,C,D,E,F,G,H$). При вставке нового элемента дерево останется сбалансированным если узел добавится после листьев $2$, $5$, $6$. При добавлении в другие места требуется корректировка дерева. Для этого выделяют два случая:

![[Drawing 2025-04-08 09.50.07.excalidraw]]
В этом случае нужно перекинуть ссылки по разным меткам

![[Drawing 2025-04-08 09.54.27.excalidraw]]
![[Drawing 2025-04-08 09.57.06.excalidraw]]

Стоит заметить, что мы рассматривали добавление в правое поддерево узла R. В случае если добавление производится в левое поддерево RL ребалансировка производится так же симметричным отражением относительно вертикальной оси. 
После ребалансировки высота получившегося дерева как была, так и остаётся равная $H$, а значит все узлы, находящиеся выше этого поддерева свой баланс не изменили. 