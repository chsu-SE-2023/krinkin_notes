Наиболее часто выполняемая задача в информационных системах - задача поиска данных. Она производится настолько часто, что даже O(n) - слишком большая.
##### Прямой поиск
Элементы последовательности просматриваются друг за другом пока не найден искомый ключ или  не просмотрена вся последовательность и ключ не найден.
В среднем при поиске одного значения из n элементов необходимо просмотреть половину последовательности - O(n).

(Находим конкретный индекc)
```
int StraightSearch(int* a, int n, int key) {
    int i = 0;
    while (i < n && a[i] != key) i++;
    if (i == n) return -1;
    else return i;
}
```

Можно заметить что в цикле while непосредственно к поиску имеет отношение лишь второе условие. Первое нужно чтобы не выйти за границы памяти. Алгоритм улучшается если увеличить массив на один элемент и перед поиском в последнем (под n) помещать искомый ключ.

```
int StraightSearch(int* a, int n, int key) {
    int i = 0;
    a[n] = key;
    while (a[i] != key) i++;
    if (i == n) return -1;
    else return i;
}
```
##### Бинарный поиск

Перед осуществлением процедуры поиска последовательность должна быть отсортирована. В ней выбираются средние элементы (`[n/2]`) и если это искомый элемент - поиск завершается. В противном случае сравниваются ключи со средним элементом: если значение меньше ключа - двигаемся влево, иначе вправо.
Сложность - $O(log2(n))$ (без учёта сортировки).

```
int BinarySearch(int* a, int n, int key) {
    int left = 0, right = n-1, i = (???+n)/2;
    while (left <= right && a[i] != key) {
        if (key < a[i]) right = i - 1;
        if (key > a[i]) left = i + 1;
        i = (left + right)/2;
    }
    if (left > right) return -1;
    else return i;
}
```
##### Деревья поиска

Будем помещать элементы последовательности в бинарное дерево:
- 1-ый - корень
- Каждый следующий по принципу: если элемент меньше корня записывается влево, больше корня - вправо. И так рекурсивно

![[Drawing 2025-04-08 02.19.43.excalidraw]]
```
#include <iostream>

struct Node{
	int data;
	Node* left, * right;
};

void formTree(Node*& root, int key) {
	if (root == NULL) {
		root = new Node;
		root->data = key;
		root->left = NULL;
		root->right = NULL;
	} else if (key < root->data)
		formTree(root->left, key);
	else if (key > root->data)
		formTree(root->left, key);
}

void printTree(Node*& root) {
	if (root != NULL) {
		printTree(root->left);
		std::cout << root->data << " ";
		printTree(root->right);
	}
}

int main() {
    const int n = 10;
	int a[n] = { 6, 3, 19, 1, 5, 2, 8, 9, 10, 7};
	Node* root = NULL;
	for (int i = 0; i < n; i++)
		formTree(root, a[i]);
	printTree(root);
	return 0;
}
```

Поиск элемента по такому дереву производится сравнением ключа, который ищем с данными в корне. Если ключ и данные совпадают - элемент найден. Если ключ меньше продолжим рекурсивно поиск в левом поддереве, если больше - в правом. В лучшем случае (дерево - сбалансированное) сложность такого поиска — $O(log2n)$. Однако в худшем случае дерево может выродится в линейный список и сложность поиска составит $O(n)$. 

> "Для вас лучше подходит невербальное общение" - Пышницкий К. М.

Дерево поиска является уже отсортированным деревом. Данные из узлов сортируются по возрастанию при симметричном обходе дерева.

==Пример==:
Пусть имеется текстовый файл в каждой строке которого записано некоторое слово. Используя дерево поиска найти частоту вхождения каждого слова в файл и вывести слова с их частотами в алфавитном порядке.
```
#include <iostream>
#include <fstream>

struct Node{
	std::string data;
	int k;
	Node* left, * right;
};

void formTree(Node*& root, std::string& key) {
	if (root == NULL) {
		root = new Node;
		root->data = key;
		root->k = 1;
		root->left = NULL;
		root->right = NULL;
	} else if (key < root->data)
		formTree(root->left, key);
	else if (key > root->data)
		formTree(root->left, key);
	else root->k++;
}

void printTree(Node*& root) {
	if (root != NULL) {
		printTree(root->left);
		std::cout << root->data << " - " << root->k << std::endl;
		printTree(root->right);
	}
}

int main() {
	const int n = 10;
	Node* root = NULL;
	std::ifstream f("input.txt");
	std::string word;
	while (!f.eof()) {
		f >> word;
		formTree(root, word);
	}
	printTree(root);
	return 0;
}
```
##### АВЛ - деревья

В 1962 году советские математики Адельсон-Вельский и Ландис предложили способ поддерживать дерево поиска всегда в сбалансированном виде, а значит организовывать поиск гарантировано со сложностью $O(log2n)$. Для своей реализации метод требует лишь дополнительных двух бит %%(байт при реализации)%% на каждый узел . Для каждого узла дерева определим фактор сбалансированности:
- $+1$ - правое поддерево на единицу выше левого, 
- $-1$ - левое на единицу больше правого, 
- $0$ - высоты левого и правого поддеревьев одинаковы.

![[Drawing 2025-04-08 09.41.26.excalidraw]]

Это сбалансированное дерево имеет высоту $4$ и $8$ внутренних узлов ($A,B,C,D,E,F,G,H$). При вставке нового элемента дерево останется сбалансированным если узел добавится после листьев $2$, $5$, $6$. При добавлении в другие места требуется корректировка дерева. Для этого выделяют два случая:

![[Drawing 2025-04-08 09.50.07.excalidraw]]
В этом случае нужно перекинуть ссылки по разным меткам

![[Drawing 2025-04-08 09.54.27.excalidraw]]
![[Drawing 2025-04-08 09.57.06.excalidraw]]

Стоит заметить, что мы рассматривали добавление в правое поддерево узла R. В случае если добавление производится в левое поддерево RL ребалансировка производится так же симметричным отражением относительно вертикальной оси. 
После ребалансировки высота получившегося дерева как была, так и остаётся равная $H$, а значит все узлы, находящиеся выше этого поддерева свой баланс не изменили. 
##### Красно-чёрные деревья

Бинарные деревья поиска, у которых для каждой вершины добавляется дополнительное свойство: вершина является чёрной или красной.
При этом требуется выполнение следующих свойств:
- корень дерева - чёрный
- у каждой красной вершины - чёрные потомки
- в любых двух ветвях от корня до листа количество содержащихся чёрных вершин равно

![[Drawing 2025-04-15 09.15.08.excalidraw]]

Для простоты реализации у всех узлов, не имеющих левого или правого потомка вместо этих потомков добавляют фиктивный чёрный узел (NULL). Все остальные узлы называются внутренними. Листом дерева - узел у которого оба потомка - фиктивные. При расчёте высоты дерева фиктивные узлы - не учитываются.

```
struct RBTree
{
  int color;
  int key;
  RBTree *parent;
  RBTree *left, *right
}
```

Для красночёрного дерева, имеющего $N$ внутренних вершин высота $log2N < H < 2*log2(N+1)$ (слева - лучший случай, справа - худший).

>"Под капотом автомобиля - красно-чёрное дерево" - Пышницкий К.М.

![[Drawing 2025-04-15 09.32.43.excalidraw]]
##### B-деревья

>"Нет, это не бинарное дерево" - Пышницкий К. М.

До сих пор мы рассматривали деревья у каждой вершины которых имелось не более двух потомков, однако степень вершин может быть больше двух. При этом будем сохранять условие сбалансированности дерева. Одним из примеров такого дерева является B-дерево. Любое B-дерево является идеально сбалансированным, отвечает условиям дерева поиска, при этом в каждой вершине находится более одного ключа. B-дерево степени $n$ определяется следующим образом:
1. Каждая вершина дерева кроме корня содержит от $n-1$ до $2n-1$ ключей и от $n$ до $2n$ указателей на потомков. Корень дерева содержит не более $2n-1$ ключей и $2n$ потомков;
2. B-дерево идеально сбалансировано - то есть высоты поддеревьев любого узла совпадают;
3. Ключи в каждой вершине упорядочены по возрастанию;
4. Если вершина содержит $k$ ключей, то у неё $k+1$ указатель на потомков. Ключи в вершине и в поддеревьях располагаются по правилу: все ключи левого поддерева меньше первого ключа узла. Значения ключей второго поддерева находятся между первым и вторым ключами узла и т.д. Ключи $k+1$ поддерева больше последнего ключа узла.

![[Drawing 2025-04-15 09.54.13.excalidraw]]

Для B-дерева степени $n$ содержащего $N$ узлов высота $H$ равна или меньше ${log2N < h < 2log2(N+1)} \over {h<=logn({N+1 \over 2})+1}$

> "Операционная система «Виндуза»" - Пышницкий К.М.

Структура каталогов файловой системы NTFS - как раз B-дерево

##### Хеш-таблицы

Этот метод требует фиксированного как правило малого времени на выполнение операции поиска. Обычно выделяют два вида хеширования:
- открытое (внешнее, расширенное);
- закрытое (внутреннее, прямое).
###### Открытое хеширование

Потенциальное множество значений ключа разбивается на конечное число классов. Для $N$ классов, пронумерованных от $0$ до $N-1$ строится хеш-функция $h$, такая что для любого $x$ из множества значений ключей функция $h(x)$ принимает целочисленное значение на отрезке $[0, n-1]$. Таким образом каждый ключ может быть отнесён к какому либо классу, а значение функции $h(x)$ называют хеш-значением от $x$. %%Слово хеш происходит из английского (hash) - рубить, измельчать%% Если ключи это целые числа, то проще всего объявить хеш-функцию $h(x)=x\%N$. При открытом хешировании каждый элемент хеш таблицы является указателем на список объектов, ключ которых имеет некоторый один и тот же хеш.

==Пример==: пусть $N=10$, $h(x)=x\%N$, а ключи (5, 3, 112, 151, 140, 106, 123, 46, 54, 82, 37)
Тогда хеш-таблица:

| Класс | Указатель на |
| ----- | ------------ |
| 0     | 140          |
| 1     | 151          |
| 2     | 112, 82      |
| 3     | 3, 123       |
| 4     | 54           |
| 5     | 5            |
| 6     | 106, 46      |
| 7     | 37           |
| 8     |              |
| 9     |              |

Поиск по такой таблице ключа со значением $key$ будет заключаться в вычислении $h(key)$ и прохождению по списку соответствующему сегменту со значением $h(key)$. В примере поиск среди 11 ключей займёт максимум две операции сравнения %%ГООООООЛ%%.
Ситуация когда два или более ключа попадают в один и тот же класс называется ==коллизией==. Для того чтобы коллизии были реже можно:
- увеличить размер хеш-таблицы (число $N$)
- изменить вид хеш-функции ($h(x)$) (например, линейно-конгруентый метод хеширования: $h(x) = (ax+b)\%N$ - коллизия будет зависеть от коофициентов $a$ и $b$)
###### Закрытое хеширование

При закрытом хешировании в таблице сегментов хранятся сами элементы, а не заголовки списков, поэтому в каждом сегменте может хранится лишь один элемент. Если элемент должен быть помещён в таблицу, а ячейка уже занята (коллизия), применяется процедура так называемого повторного хеширования. Одна из самых простых функций для закрытого хеширования: $h_{i}(x) = (h_{0}(x)+i)\%N$. 

==Пример==: пусть $N=10$, $h(x)=x\%N$, а ключи (5, 3, 112, 151, 140, 106, 123, 46, 54, 82, 37)
Тогда хеш-таблица:

| Класс | Значение |
| ----- | -------- |
| 0     | 140      |
| 1     | 151      |
| 2     | 112      |
| 3     | 3        |
| 4     | 123      |
| 5     | 5        |
| 6     | 106      |
| 7     | 46       |
| 8     | 54       |
| 9     |          |

$h_{0}(123) = 3$ 
$h_{1}(123) = (3+1)\%10 = 4$ 

$h_{0}(46) = 6$ 
$h_{1}(46) = (6+1)\%10 = 7$ 

$h_{0}(54) = 4$ 
$h_{1}(54) = (4+1)\%10 = 5$
$h_{2}(54) = (4+2)\%10 = 6$ 
$h_{3}(54) = (4+3)\%10 = 7$ 
$h_{4}(54) = (4+4)\%10 = 8$ 

Ещё одна проблема возникает при удалении элемента: с одной стороны ячейка освобождается, а значит в ней должно быть значение "пустая", но с другой поиск элементов по таблице производится вычислением значений $h_{0}(x)$, $h_{1}(x)$ и т.д., пока элемент не будет найден, не просмотрена вся таблица или не встретится пустая ячейка, поэтому ячейку из которой удалён элемент нельзя делать пустой. В примере если удалить 5, не сможем найти 54. Поэтому при удалении ячейка должна быть помечена не как пустая, а как "удалённая" - при добавлении элемента считается пустой, а при поиске заполненной.
Ещё одной проблемой является возникновение большого числа коллизий и как следствие длинные цепочки повторного хеширования. В связи с этим, для разрешения коллизий вводят другой вид функции $h_{i}(x)$, например: $h_{i}(x) = (h_{0}(x)+j_{i})\%N$, где $j_{1}, j_{2}, ..., j_{n-1}$ - случайная перестановка чисел $1, 2, ..., n-1$.