Наиболее часто выполняемая задача в информационных системах - задача поиска данных. Она производится настолько часто, что даже O(n) - слишком большая.
##### Прямой поиск
Элементы последовательности просматриваются друг за другом пока не найден искомый ключ или  не просмотрена вся последовательность и ключ не найден.
В среднем при поиске одного значения из n элементов необходимо просмотреть половину последовательности - O(n).

(Находим конкретный индекc)
```
int StraightSearch(int* a, int n, int key) {
    int i = 0;
    while (i < n && a[i] != key) i++;
    if (i == n) return -1;
    else return i;
}
```

Можно заметить что в цикле while непосредственно к поиску имеет отношение лишь второе условие. Первое нужно чтобы не выйти за границы памяти. Алгоритм улучшается если увеличить массив на один элемент и перед поиском в последнем (под n) помещать искомый ключ.

```
int StraightSearch(int* a, int n, int key) {
    int i = 0;
    a[n] = key;
    while (a[i] != key) i++;
    if (i == n) return -1;
    else return i;
}
```
##### Бинарный поиск

Перед осуществлением процедуры поиска последовательность должна быть отсортирована. В ней выбираются средние элементы (`[n/2]`) и если это искомый элемент - поиск завершается. В противном случае сравниваются ключи со средним элементом: если значение меньше ключа - двигаемся влево, иначе вправо.
Сложность - $O(log2(n))$ (без учёта сортировки).

```
int BinarySearch(int* a, int n, int key) {
    int left = 0, right = n-1, i = (???+n)/2;
    while (left <= right && a[i] != key) {
        if (key < a[i]) right = i - 1;
        if (key > a[i]) left = i + 1;
        i = (left + right)/2;
    }
    if (left > right) return -1;
    else return i;
}
```
##### Деревья поиска

Будем помещать элементы последовательности в бинарное дерево:
- 1-ый - корень
- Каждый следующий по принципу: если элемент меньше корня записывается влево, больше корня - вправо. И так рекурсивно

![[Drawing 2025-04-08 02.19.43.excalidraw]]
```
#include <iostream>

struct Node{
	int data;
	Node* left, * right;
};

void formTree(Node*& root, int key) {
	if (root == NULL) {
		root = new Node;
		root->data = key;
		root->left = NULL;
		root->right = NULL;
	} else if (key < root->data)
		formTree(root->left, key);
	else if (key > root->data)
		formTree(root->left, key);
}

void printTree(Node*& root) {
	if (root != NULL) {
		printTree(root->left);
		std::cout << root->data << " ";
		printTree(root->right);
	}
}

int main() {
    const int n = 10;
	int a[n] = { 6, 3, 19, 1, 5, 2, 8, 9, 10, 7};
	Node* root = NULL;
	for (int i = 0; i < n; i++)
		formTree(root, a[i]);
	printTree(root);
	return 0;
}
```

Поиск элемента по такому дереву производится сравнением ключа, который ищем с данными в корне. Если ключ и данные совпадают - элемент найден. Если ключ меньше продолжим рекурсивно поиск в левом поддереве, если больше - в правом. В лучшем случае (дерево - сбалансированное) сложность такого поиска — $O(log2n)$. Однако в худшем случае дерево может выродится в линейный список и сложность поиска составит $O(n)$. 

> "Для вас лучше подходит невербальное общение" - Пышницкий К. М.

Дерево поиска является уже отсортированным деревом. Данные из узлов сортируются по возрастанию при симметричном обходе дерева.

Пример:
Пусть имеется текстовый файл в каждой строке которого записано некоторое слово. Используя дерево поиска найти частоту вхождения каждого слова в файл и вывести слова с их частотами в алфавитном порядке.
```
#include <iostream>
#include <fstream>

struct Node{
	std::string data;
	int k;
	Node* left, * right;
};

void formTree(Node*& root, std::string& key) {
	if (root == NULL) {
		root = new Node;
		root->data = key;
		root->k = 1;
		root->left = NULL;
		root->right = NULL;
	} else if (key < root->data)
		formTree(root->left, key);
	else if (key > root->data)
		formTree(root->left, key);
	else root->k++;
}

void printTree(Node*& root) {
	if (root != NULL) {
		printTree(root->left);
		std::cout << root->data << " - " << root->k << std::endl;
		printTree(root->right);
	}
}

int main() {
	const int n = 10;
	Node* root = NULL;
	std::ifstream f("input.txt");
	std::string word;
	while (!f.eof()) {
		f >> word;
		formTree(root, word);
	}
	printTree(root);
	return 0;
}
```
##### АВЛ - деревья

В 1962 году советские математики Адельсон-Вельский и Ландис предложили способ поддерживать дерево поиска всегда в сбалансированном виде, а значит организовывать поиск гарантировано со сложностью $O(log2n)$. Для своей реализации метод требует лишь дополнительных двух бит %%(байт при реализации)%% на каждый узел . Для каждого узла дерева определим фактор сбалансированности:
- $+1$ - правое поддерево на единицу выше левого, 
- $-1$ - левое на единицу больше правого, 
- $0$ - высоты левого и правого поддеревьев одинаковы.

![[Drawing 2025-04-08 09.41.26.excalidraw]]

Это сбалансированное дерево имеет высоту $4$ и $8$ внутренних узлов ($A,B,C,D,E,F,G,H$). При вставке нового элемента дерево останется сбалансированным если узел добавится после листьев $2$, $5$, $6$. При добавлении в другие места требуется корректировка дерева. Для этого выделяют два случая:

![[Drawing 2025-04-08 09.50.07.excalidraw]]
В этом случае нужно перекинуть ссылки по разным меткам

![[Drawing 2025-04-08 09.54.27.excalidraw]]
![[Drawing 2025-04-08 09.57.06.excalidraw]]

Стоит заметить, что мы рассматривали добавление в правое поддерево узла R. В случае если добавление производится в левое поддерево RL ребалансировка производится так же симметричным отражением относительно вертикальной оси. 
После ребалансировки высота получившегося дерева как была, так и остаётся равная $H$, а значит все узлы, находящиеся выше этого поддерева свой баланс не изменили. 
##### Красно-чёрные деревья

Бинарные деревья поиска, у которых для каждой вершины добавляется дополнительное свойство: вершина является чёрной или красной.
При этом требуется выполнение следующих свойств:
- корень дерева - чёрный
- у каждой красной вершины - чёрные потомки
- в любых двух ветвях от корня до листа количество содержащихся чёрных вершин равно

![[Drawing 2025-04-15 09.15.08.excalidraw]]

Для простоты реализации у всех узлов, не имеющих левого или правого потомка вместо этих потомков добавляют фиктивный чёрный узел (NULL). Все остальные узлы называются внутренними. Листом дерева - узел у которого оба потомка - фиктивные. При расчёте высоты дерева фиктивные узлы - не учитываются.

```
struct RBTree
{
  int color;
  int key;
  RBTree *parent;
  RBTree *left, *right
}
```

Для красночёрного дерева, имеющего $N$ внутренних вершин высота $log2N < H < 2*log2(N+1)$ (слева - лучший случай, справа - худший).

>"Под капотом автомобиля - красно-чёрное дерево" - Пышницкий К.М.

![[Drawing 2025-04-15 09.32.43.excalidraw]]
##### B-деревья

>"Нет, это не бинарное дерево" - Пышницкий К. М.

До сих пор мы рассматривали деревья у каждой вершины которых имелось не более двух потомков, однако степень вершин может быть больше двух. При этом будем сохранять условие сбалансированности дерева. Одним из примеров такого дерева является B-дерево. Любое B-дерево является идеально сбалансированным, отвечает условиям дерева поиска, при этом в каждой вершине находится более одного ключа. B-дерево степени $n$ определяется следующим образом:
1. Каждая вершина дерева кроме корня содержит от $n-1$ до $2n-1$ ключей и от $n$ до $2n$ указателей на потомков. Корень дерева содержит не более $2n-1$ ключей и $2n$ потомков;
2. B-дерево идеально сбалансировано - то есть высоты поддеревьев любого узла совпадают;
3. Ключи в каждой вершине упорядочены по возрастанию;
4. Если вершина содержит $k$ ключей, то у неё $k+1$ указатель на потомков. Ключи в вершине и в поддеревьях располагаются по правилу: все ключи левого поддерева меньше первого ключа узла. Значения ключей второго поддерева находятся между первым и вторым ключами узла и т.д. Ключи $k+1$ поддерева больше последнего ключа узла.

![[Drawing 2025-04-15 09.54.13.excalidraw]]

Для B-дерева степени $n$ содержащего $N$ узлов высота $H$ равна или меньше ${log2N < h < 2log2(N+1)} \over {h<=logn({N+1 \over 2})+1}$

> "Операционная система «Виндуза»" - Пышницкий К.М.

Структура каталогов файловой системы NTFS - как раз B-дерево