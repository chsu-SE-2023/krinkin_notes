Часть задач выбора можно решить существенно быстрее, чем полным перебором. Одним из методов, позволяющих это сделать является метод динамического программирования. Суть заключается в том что некоторая общая большая задача на более мелкие, те в свою очередь на ещё более мелкие пока не дойдём до задачи минимального размера. В начале решается минимальная задача. На основе её решения - задача следующего уровня и так далее, пока не будет решена задача изначального размера. При переходе от задачи размером $k$ к задаче размером $k+1$ в методе динамического программирования пользуются принципом оптимальности Беллмана, на основании которого и просчитывается задача следующего уровня. Выигрыш заключается в том что задачи каждого уровня решаются только однократно, а затем их решение используется на следующих шагах. К сожалению метод динамического программирования %%(Да...)%%
###### Пример 1

В предыдущем примере вместо полного перебора можно воспользоваться ещё одним двумерным массивом.
$$A =
\begin{pmatrix}
1 & 1 & 1 & 1 \\
1 & 2 & 1 & 1 \\
1 & 3 & 4 & 1 \\
1 & 1 & 2 & 1
\end{pmatrix}
$$
$$B =
\begin{pmatrix}
1 & 2 & 3 & 4 \\
2 & 4 & 5 & 1 \\
3 & 7 & 11 & 12 \\
4 & 8 & 13 & 14
\end{pmatrix}
$$
Когда мы выходим из клетки (0, 0) сумма изменится на значение a(0, 0) =>

```
b[0][0] = a[0][0]
b[0][1] = b[0][0] + a[0][1]
b[1][0] = b[0][0] + a[1][0]
b[1][1] = max(b[0][1] + a[1][1], b[1][0] + a[1][1])
b[i][j] = max(b[i-1][j] + a[i][j], b[i][j-1] + a[i][j]) - принцип оптимальности
```

Значение `b` с индексом `[1][1]` будет ни что иное как максимум между `b[0][1]+a[1][1]` и `b[1][0]+a[1][1]`. Тем самым мы решили задачу размером 2x2. Аналогичным образом будем решать задачи большего размера, пользуясь правилом `b[i][j] = max(b[i-1][j]+a[i][j], b[i][j-1]+a[i][j])` для всех `i, j > 0`. Это и есть принцип оптимальности.

Если необходимо найти не только значение максимальной суммы, но и путь по которому она получена, это можно сделать в массиве $B$, двигаясь от конечного элемента к элементу `b[0][0]` по жадному алгоритму, каждый раз переходя к большему соседу.
###### Пример 2 (Задача о министерстве)

Некто хочет подписать документ у министра. Министр подписывает бумагу только если на ней стоит подпись любого работника с последнего этажа министерства. Министерство имеет размер NxM, где 1<=N<=100 - количество этажей, 1<=M<=500 - количество кабинетов на этаже. Каждый работник министерства сидит в отдельном кабинете и подписывает документ если его уже подписали в одном из соседних кабинетов или в кабинете с тем же номером на предыдущем этаже. На первом этаже документ может подписать любой кабинет. За свою подпись каждый работник министерства берёт пошлину (взятку). Известно что сумма взятки в каждом кабинете министерства различна. Найти такой путь с первого этажа на последний суммарная взятка была минимальной.

$$A =
\begin{pmatrix}
10 & 10 & 1 & 10 \\
10 & 10 & 1 & 10 \\
1 & 1 & 1 & 10 \\
1 & 10 & 10 & 10
\end{pmatrix}
$$
$$B =
\begin{pmatrix}
22 & 23 & 6 & 25 \\
12 & 13 & 5 & 15 \\
2 & 3 & 4 & 14 \\
1 & 10 & 10 & 10
\end{pmatrix}
$$
$$C =
\begin{pmatrix}
0 & 0 & [0] & 0 \\
0 & 0 & 0 & -1 \\
0 & -1 & -1 & -1 \\
0 & 0 & 0 & 0
\end{pmatrix}
$$

Будем просчитывать значение минимальной взятки для каждого кабинета, начиная с первого этажа , постепенно двигаясь по этажам. Каждый следующий этаж будем просчитывать на основе предыдущего. Принцип оптимальности - `b[i][j] = min(b[i-1][j]+a[i][j], b[i][j-1]+a[i][j], b[i][j+1]+a[i][j])` - для всех `i>1 1<j<M-1`. Когда будет заполнен последний этаж найдём на нём минимум - это и будет искомая сумма взятки. Если надо найти путь - можно завести ещё один массив $C$ в котором для каждого кабинета будем отмечать откуда в него пришли: `0` - снизу, `-1` - слева, `1` - справа. В программе будем читать данные из файла, считая что в верхней строке файла записаны взятки первого этажа министерства, во второй - второго и т.д. При этом можно заметить что совсем не обязательно заводить двумерные массивы $A$ и $B$. Достаточно держать держать данные текущего этажа и просчитанный предыдущий.
###### Пример 3 (Задача о рюкзаке (вор на складе))
Имеется n видов предметов массами $m1, m2, ..., mn$ и стоимостями $s1, s2, …, sn$. Предметов каждого вида неограниченно. Также имеется рюкзак, который может вместить груз массой не более $M$. Определить какое количество предметов каждого вида нужно поместить в рюкзак, чтобы стоимость рюкзака была максимальной.

Будем заполнять предметами первого вида все рюкзаки начиная с вместимости $0$, далее $1$ и т.д. до $M$. На следующем шаге в каждый из рюкзаков будем пытаться поместить предметы второго вида в количестве $0, 1$ до возможного максимума. Когда мы поместим в рюкзак предметы второго вида в количестве $k$, у него ещё останется место для предметов первого вида, а это уже просчитано на предыдущем этапе. Из всех вариантов добавления предметов второго вида выбираем тот, где сумма максимальная (принцип оптимальности).