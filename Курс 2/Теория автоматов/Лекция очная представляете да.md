##### Грамматика языка Милан

###### Описание модельного языка
Вариант 1 (программа):
P -> program Di; Bi
Di -> var D {, D}
D -> I {, I}: [int | bool]
B -> begin S {; S} end
S ->
...

Вариант 2 (составной оператор):
П -> begin L end
L -> S | S; L
S -> I := E | while B do L | if B then L | if B then L else L | write (E)
B -> E Q E
Q -> = | != | < | > | <= | >=
E -> I | C | (E) | E+E | E-E | E\*E | E/E | read
I -> б | 1 б | 1 ц     ц -> id
C -> ц | C ц          ц -> const

Вариант 3:
П -> begin L end
L -> S | S; L
S -> I = E | while B do L od | if B then L 
...

##### Синтаксис языка программирования
**Синтаксис программы** - структура и форма записи её текста. Синтаксис задаётся правилами, позволяющими определелить, принадлежит ли выражение/инструкция языку или нет.

На этапе анализа нужно:
- Установить, имеет ли цепочка лексем структуру, заданную синтаксисом языка
- Зафиксировать эту структуру

Некоторые синтаксические ошибки языка C++
- Ошибки в синтаксической конструкции
- Основное правило синтаксиса C++ - в конце каждой инструкции использовать точку с запятой
- Для разделения блоков кода используют фигурные скобки
- В C++ существует строгая типизация переменных. Это означает, что указать тип данных переменной нужно до её использования
- Названия переменных могут содержать буквы, шифры и символ подчёркивания, но не могут начинаться с цифры (это также и правило лексического анализатора)

##### Семантика языка программирования
**Семантика языка** - описание смысла языковых выражений

Семантику составляют правила, определяющие, к выполнению каких действий приведёт то или иное выражение.

Некоторые семантические правила
1. Любое имя, используемое в программе, должно быть описано и только один раз
2. В операторе присваивания типы должны ...
3. 

Формальных правил описания семантики нет

##### Упражнение

w =`begin id := id + const; write(id) end`

Левостороннее порождение

%%Это нужно писать в одну строку%%
~~П~~ => 
begin ~~L~~ end => 
begin ~~S~~; L end => 
begin ~~I~~ := E ; L end => 
begin id := ~~E~~; L end => 
begin id := ~~E~~+E; L end => 
begin id := ~~I~~+E; L end => 
begin id := id + ~~E~~; L end; => 
begin id := id + ~~C~~; L end => 
begin id := id + const; ~~L~~ end => 
begin id := id + const; ~~S~~ end => 
begin id := id + const; write(~~E~~) end => 
begin id := id + const; write(~~I~~) end => 
begin id := id + const; write(id) end

Правосторонее порождение

~~П~~ =>
begin ~~L~~ end =>
begin S; ~~L~~ end =>
begin S; write(~~E~~) end =>
begin S; write(~~I~~) end =>
begin ~~S~~; write(id) end =>
begin I := ~~E~~; write(id) end =>
begin I := E + ~~E~~; write(id) end =>
begin I := E + ~~C~~; write(id) end =>
begin I := ~~E~~ + const; write(id) end =>
begin I := ~~I~~ + const; write(id) end =>
begin ~~I~~ := id + const; write(id) end =>
begin id := id + const; write(id) end

Дерево вывода
![[Drawing 2025-03-28 13.04.34.excalidraw]]
Дома прописать грамматику с точки зрения терминальных и не терминальных символов
\+ Конспекты в тетради