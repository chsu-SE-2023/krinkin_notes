`Граф` - любое конечное множество точек (вершин), некоторые из которых попарно соединены стрелками (дугами) можно рассматривать как граф. %%6 класс ср. школы%%

![[Drawing 2025-04-08 08.30.40.excalidraw]]

Две вершины могут быть соединены несколькими дугами, идущими в одном направлении такие дуги называются кратными, а граф, содержащий кратные дуги - мультиграфом. В дальнейшем будем оперировать с простыми графами без кратных дуг.
##### Определение
Простым ориентированным графом называется пара объектов $G=(V, E)$, где $V$ - конечное множество, $E$ - подмножество декартова произведения $V×V$

$A×B$ - множество всех пар вида $(a, b)$, где $a ∈ A, а b ∈ B$

Дуга представима в виде упорядоченной пары вершин $(v1, v2)$, где $v1$ - начало, $v2$ - конец дуги. При этом говорят что дуга $v1$, $v2$ ведёт от вершины $v1$ к вершине $v2$, а вершина $v2$ - смежная с вершиной $v1$. Граф $G$ называется симметрическим если из того что дуга $(vi, vj)$ принадлежит множеству $E$ следует что и дуга $(vj, vi)$ также принадлежит множеству $E$. Часто в симметрических графах пары дуг $(vi, vj)$ и $(vj, vi)$ заменяют рёбрами и такие графы называют неориентированными.

Пусть существует граф $G$. Дугу $u ∈ E$ и вершину $v ∈ V$ называют инцидентными если дуга u либо входит в вершину V, либо выходит из неё. Степенью вершины v называется количество инцидентны её дуг или рёбер. Путём в графе G называется последовательность вершин $(v1, v2, …, vn)$ для которой существуют дуги $(v1, v2), (v2, v3), …, (vn-1, vn)$. Длина пути - количество дуг, составляющих этот путь. Иногда каждой дуге ставят в соответствие некоторую стоимость или вес. Такой граф называют взвешенный. Длиной пути в таком графе называется сумма весов дуг, составляющих этот путь. Путь называется простым, если все вершины в нём за исключением быть может первой и последней различны. 

`Цикл` - простой путь, длиной не менее единицы, который начинается и заканчивается в одной и той же вершине. Среди циклов выделяют несколько особенных:
- Эйлеров цикл (об этом цикле очень скоро поговорим) - цикл, проходящий однократно через все дуги графа;
- Гамельтонов цикл - простой цикл, проходящий через все вершины графа;

Граф $G$ называется сильносвязным если для любых двух вершин $(vi, vj)$, принадлежащих множеству $V$, таких чтобы $i != vj$ существует путь из вершины $vi$ в вершину $vj$. Подграф $G'$ графа $G$ называется компонентой связности если $G'$ связен, $G'$ обладает свойством максимальности - не существует вершины $vi$, не принадлежащей $G'$, такой что при добавлении $vi$ к $G'$ получается связный граф.
###### Способы представления графов

- Матрица смежности - матрица $(A)$ размером $n×n$, где $n$ - количество вершин графа, где `A[i][j] = 1`, когда существует дуга $(i, j)$, все остальные элементы матрицы равны нулю. Главным плюсом матрицы смежности является прямой доступ к каждому элементу, то есть за одну операцию можно узнать существует дуга $(I, j)$ или нет. Минусом является количество памяти пропорционально $n^2$, но и обход всего графа также $n^2$. Если граф взвешенный, матрица смежности часто заменяется матрицей стоимости.
- Списки смежности - одномерный массив указателей, каждый элемент которого содержит адрес списка смежных с ним вершин. Преимущество списка смежности перед матрицей смежности проявляется только в том случае, когда в графе много вершин и мало дуг.
###### Задача о кенигсбергских мостах

Город Кенигсберг располагался на двух берегах р. Прегель и двух островах, которые некоторым образом (см. рис) соединялись мостами. Вопрос: можно ли выйдя из дома прогуляться по каждому из мостов ровно по одному разу, вернувшись затем домой. Моделью данной задачи является граф (рис), а сама задача - существование эйлерового цикла в графе.
##### Теорема Эйлера
Эйлеров цикл в неориентированном связном графе существует тогда и только тогда, когда степени всех вершин графа - чётные.
###### Алгоритм построения эйлерового цикла
1. Произвольно выбрать начальную вершину $v0$;
2. Произвольно выбрать некоторое ребро u инцидентное (дуга входит или выходит из вершины) вершине и присвоить ему номер $1$, здесь же будем говорить что ребро пройдено;
3. Каждое пройденное ребро будем вычёркивать и присваивать ему номер на единицу больший предыдущего вычеркнутого ребра;
4. Находясь в вершине $vi$ не вычёркивать рёбра ведущие в вершину $v0$, если есть другой вариант;
5. Находясь в вершине $vi$ не вычёркивать рёбра являющиеся перешейком - при вычёркивании такого ребра граф распадается на две области связности;
6. Рёбра $u1, u2, …, uk$ с номерами $1, 2, …, k$ и будут составлять эйлеров цикл в графе.
##### Обход графа в ширину (волновой обход графа)

![[Pasted image 20250408090954.png]]

Пусть имеется произвольный граф $G$ (ориентированный/неориентированный), граф не является взвешенным. Требуется найти путь минимальной длины из вершины $vi$ в вершину $vj$ или сообщить о том что такого пути не существует. Данную задачу можно решить обходом графа в ширину начиная с вершины $vi$. Присвоим вершине $vi$ метку $0$, а всем вершинам смешным с $vi$ метку $1$. Далее всем непомеченным вершинам смежным с 1 присвоим метку $2$ и так далее пока вершина $vj$ не получит метку или не будет вершин смежных с помеченными на предыдущем шаге ещё без метки. В первом случае метка вершины $vj$ и есть длина минимального пути, во втором вершина $vj$ находится в другой области связности графа и пути не существует. Метка вершины $vj$ является длиной пути сам путь можно найти двигаясь от $vj$ к $vi$ каждый раз переходя в вершину на единицу меньше.

```
public int makeWave(int a, int b) {
    int path[] = new int[size+1];
    for (int i = 1; i <= size; i++) path[i] = -1 // Заполнение путей -1;
    path[a] = 0; // Начальная метка
    int num = 1, i = 1; // num - номер текущей метки
    boolean f = false, f1 = true; // f - флаг посещения, f1 - существуют ли непосещённые
    do {
        while (i <= size && path[i] != num-1) i++; // Поиск предыдущей метки
        if (i <= size) {
            f = true;
            for (int j = 1; j <= size; j++)
                // gr - матрица смежности, path - массив меток
                if (gr[i][j] == 1 & path[j] == -1) path[j] = num; // Присвоение метки
            i++;
        }
        else {
            if (f) {i = 1; f = false; num++;} else f1 = false;
        }
    }
    while (f1);
    return path[b];
}
```
##### Алгоритм Дейкстры

Если в отличие от предыдущей задачи граф взвешенный, то путь минимальной стоимости может иметь самую замысловатую траекторию. Стандартный алгоритм находящий такой путь во взвешенном графе был предложен Дейкстрой.

![[Pasted image 20250408091215.png]]

Пусть имеется взвешенный граф $G$ (ориентированный/неориентированный), веса всех рёбер графа не отрицательные числа. Требуется найти путь минимальной стоимости из вершины $vi$ в вершину $vj$.

1. Присвоим вершине $vi$ метку $0$. Будем считать эту метку постоянной;
2. Всем остальным вершинам графа присвоим временные метки + бесконечность;
3. Возьмём вершину получившую постоянную метку на предыдущем шаге и для каждой вершины vj смежной с vi пересчитаем временную метку по принципу metka[j] = min(metka[j], metka[i]+gr[i][j]);
4. Среди всех временных меток найдём минимальную и сделаем эту метку постоянной. Если при этом вершина в которую мы хотели попасть получила постоянную метку идём на пункт 5, иначе на пункт 3;
5. Постоянная метка конечной вершины vj и есть стоимость искомого пути. Сам путь можно найти двумя способами: двигаться от последней вершины в обратном направлении каждый раз к такой вершине, метка которой равна метке данной минус стоимость ребра между ними; завести одномерный массив в j-ый элемент которого будем заносить номер вершины через которую была пересчитана метка j-ой вершины.

```
public class Deikstra {
    int[][] gr; // Матрица смежности
    int size;
    class Metka {
        int volume, type;
    }
    Metka[] m; // Массив меток
}

public int findPath(int a, int b) {
    m[a].volume = 0;
    m[a].type = 1;
    int i = a;
    // ^ Начальная метка
    for (int j = 1; j <= size; j++)
        if (j != i) { // Установка бесконечных меток
            m[j].volume = Integer.MAX_VALUE;
            m[j].type = 0;
        }
        while (i != b) {
            for (int j = 1; j <= size; j++)
                if (gr[i][j] != 0 && m[j].type == 0) // Если путь есть и метка временная
                    if(m[j].volume > m[i].volume+gr[i][j]) {
                        m[j].volume = m[i].volume+gr[i][j]; // Пересчёт
                    }
            int min = Integer.MAX_VALUE, nmin = 0;
            for (int j = 1; j <= size; j++)
                // Поиск минимальной метки
                if (m[j].volume < min && m[j].type == 0) {
                    min = m[j].volume;
                    nmin = j;
                }
            m[nmin].type = 1;
            i = nmin;
        }
    return m[b].volume;
}
```
##### Алгоритм Флойда

Алгоритм Флойда использует матрицу A размером NxN в которой вычисляются длины кратчайших путей между всеми парами вершин. Изначально матрица A совпадает с матрицей стоимости, но если прямого пути из вершины i в вершину j нет, A[i][j] = +INF. Кроме того все A[i][i] равны нулю. Над матрицей A проводится n итераций. На k-ой итерации A[i][j] содержит значение наименьшей длины пути из вершины i в вершину j, который не проходит через вершины с номерами большими k.
`
```
Ak[i][j] = min(Ak-1[i][j], Ak-1[i][k] + Ak-1[k][j])
for (int k = 1; k <= size; k++)
    for (int i = 1; i <= size; i++)
        for (int j = 1; j <= size; j++)
            if (a[j][k] + a[k][j] < a[i][j]) = a[i][j] = a[i][k] + a[k][j];
```

Если в графе $n$ вершин, то сложность работы алгоритма пропорциональна $n^3$.
##### Транзитивное замыкание

В ряде задач интерес вызывает не длина пути между вершинами $i$ и $j$, а лишь его наличие это можно решить алгоритмом Флойда, но изначально был предложен несколько другой алгоритм (автор его Воршелл). Пусть имеются матрица смежности $A$ некоторого графа $G$. Требуется преобразовать её к такому виду что `a[i][j] = 1` тогда и только тогда, когда существует путь из вершины $i$ в вершину $j$ длиной не менее $1$ и `A[i][j] = 0` в противном случае. Такую матрицу называют транзитивным замыканием графа $G$. Если считать `0 = false`, а `1 = true`, то транзитивным замыканием аналогично алгоритму Флойда вычисляется по формуле:

`Ak[i][j] = Ak-1[i][j] or (Ak-1[i][k] and Ak-1[k][j])`
##### Обход графа в глубину

Пусть имеется граф $G$ в котором первоначально все вершины имеют метку "не посещалась". Обход в глубину начинается с выбора начальной вершины $v0$, которая отмечается как "посещена", затем для каждой вершины смежной с $v0$, которая ещё не посещалась рекурсивно применяется обход в глубину. Когда все вершины, которые можно достичь из вершины $v0$ будут посещены обход завершается. Если при этом какие-то вершины ещё будут не посещены выбирается одна из них и обход повторяется начиная с неё. Данный метод называется обходом в глубину так как путь в графе идёт вглубь начиная с некоторой вершины пока это возможно.

![[Pasted image 20250408093730.png]]

В процессе обхода графа в глубину только определённые дуги ведут к вершинам, которые не посещались. То какие из дуг будут выбраны и в каком порядке зависит от выбора начала вершины и порядка обхода вершин. Так формируется так называемый глубинный оставный лес графа $G$.

```
#include <iostream>
#include <fstream>

class MyGraph {
private:
    int gr[100][100]; // Можно заменить на динамический
    int metka[100];
    int n;
    int num;
    void obhod(int i) {
        metka[i] = num++;
        for (int j = 0; j < n; j++)
            if (gr[i][j] != 0 && metka[j] == 0)
                obhod(j);
    }

public:
    MyGraph(std::string name) {
        std::ifstream f(name);
        f >> n;
        for (int i = 0; i < n; i++)
            for (int j = 0; j < n; j++)
                f >> gr[i][j];
        f.close();
        for (int i = 0; i < n; i++)
            metka[i] = 0;
    }

    void glubina() {
        num = 1;
        for (int i = 0; i < n; i++)
            if (metka[i] == 0)
                obhod(i);
    }

    void vivodMetka() {
        for (int i = 0; i < n; i++)
            std::cout << metka[i] << " ";
        std::cout << std::endl;
    }
};

int main() {
    MyGraph g("input.txt");
    g.glubina();
    g.vivodMetka();
    return 0;
}
```

Обход в глубину часто используется при решении различных задач

##### Поиск циклов в графе

Если при обходе в глубину встретилась обратная дуга, ведущая к уже посещённой вершине, то в графе существует цикл. Верно и обратное: если в графе существует цикл, то при обходе в глубину обязательно встретится обратная дуга. Таким образом глубинный обход графа можно использовать для поиска в нём циклов.

##### Компоненты сильной связности в графе
Сильносвязной компонентой графа называют множество вершин в котором существует путь из любой вершины в любую другую (не только напрямую).

Алгоритм
1. Выполняется обход графа в глубину, причём вершины помечаются номерами не в начале, а в конце процедуры рекурсивного обхода.
2. Конструируем новый граф $G'$ путём смены направления всех дуг графа $G$.
3. Начинаем обход графа в глубину с вершины, получившей максимальный номер на предыдущем этапе. Если проведённый обход не охватил все вершины повторим с вершины имеющей наибольший номер из оставшихся.
4. Каждое дерево, полученное при обходе графа $G'$ и есть компонента сильной связности графа $G$.

##### Алгоритм Прима

Задача
В городе $N$ существует n промышленных предприятий, которые время от времени тянули к друг другу линии связи. Когда руководители предприятий собрались на $N$-ской конференции по IT технологиям выяснилось, что некоторые линии можно безболезненно удалить (например, если предприятие $A$ соединено с $B$, $B$ соединено с $C$, а $С$ соединена с $A$, то одна из линий не обязательна). В целях экономии желательно удалять линии наибольшей длины. Известно какие из $N$ предприятий с какими и длины этих линий. Определить суммарную длину линий, которые можно удалить, чтобы эта длина была максимальной. Задача сводится к нахождению оставного дерева минимальной стоимости в графе. Этот остав нужно оставить, а остальные рёбра удалить. Рассмотрим алгоритм на одной области связности.

Алгоритм
1. Заведём два множества $V$ - всех вершин графа и $U$ - пустое.
2. Поместим во множество $U$ произвольную вершину графа $G$.
3. Среди рёбер соединяющих вершины множества $U$ с вершинами множества $V/U (V-U)$ найдём ребро минимальной стоимости. Отметим это ребро, а вершину в которую оно ведёт поместим во множество $U$.
4. Если множество $U$ равно множеству $V$, алгоритм закончен и отмеченные рёбра составляют оставное дерево минимальной стоимости. Если $U$ не равно $V$, идём на пункт 3.