**Функция** - именованная последовательность описаний и операторов выполняющая некоторое законченное действие. Функция может принимать параметры и возвращать значения. Наиболее широкое применение функции получили в парадигмах функционального, структурного и объектно-ориентированного программирования.

Принципы структурного программирования:
1. Любая программа строится из трёх базовых управляющих конструкций: последовательность, ветвление, цикл.
2. В программе базовые управляющие конструкции могут быть вложены друг в друга произвольным образом.
3. Повторяющиеся фрагменты программы можно оформить в виде подпрограмм (процедур/функций).
4. Каждую логически законченную группу инструкций следует оформить как блок.
5. Все перечисленные конструкции должны иметь один вход и один выход.
6. Разработка программы ведётся пошагово, методом "сверху-вниз".

##### Объявление и определение функций в C

`[класс] тип имя ([список параметров]) [throws (исключения)] {тело функции}`

`int sum(int a, int b); // Объявление функции`
`int sum (int a, int b) {return a + b;} // Определение функции`

Необязательный модификатор класс может явно задать область видимости функции:
- `extern` - функция видна во всех модулях программы, используется по умолчанию.
- `static` - функция видна только в текущем модуле.

Тип возвращаемого значения может быть любым, кроме массивов и функций, но может быть указателем на массив или указателем на функцию. Если функция не возвращает никакого значения её тип void.

Через параметры в функцию передаются значения с которыми функция будет работать. Параметры перечисляются через запятую, для каждого параметра указывается тип и имя.

В ходе работы функции может возникнуть нештатная исключительная ситуация. Например деление на ноль, попытка чтения из несуществующего файла и т.д. Функция может выбросить объект называемый исключением, который затем будет обработан в месте вызова функции.

Описание функции состоит из двух частей: заголовка (объявление прототипа функции) и определения функции. Заголовок и определение могут располагаться в разных частях программы. Часто заголовки перечисляются перед функцией main(), а определение всех функций производится ниже main(). В заголовках функции обязательно указывать имя, тип возвращаемого значения и типы параметров. В определении обязательно указывать имена параметров и тело функции.

##### Локальные и глобальные переменные

- Переменная, описанная внутри функции называется "локальная" и может использоваться только в теле этой функции.
- Переменная, описанная в программе перед описанием функций называется "глобальная" и может использоваться в любой функции, включая main(). Использование глобальных переменных в функциях является дурным тоном.

##### Формальные и фактические параметры

Функция вызывается в любом месте программы ниже её объявления указанием имени функции и перечислением необходимых параметров  в скобках. Параметры, указанные в заголовке функции называются "формальными", т.к. изначально они никаких значений не несут, а лишь формально показывают что с ними необходимо делать в теле функции. Параметры, перечисленные при вызове функции называются "фактическими", т.к. они передают фактические значения формальным параметрам. Количество, порядок и тип формальных и фактических параметров должны соответствовать.

##### Механизмы передачи параметров

Параметры внутрь функции можно передать тремя способами:
1. По значению: В примере (code1.cpp) в функцию f() параметр n передавался по значению. Внутри функции он описан как простая переменная (int n) и для него заводится в памяти ещё одна ячейка. При вызове функции происходит копирование значения фактического параметра в ячейку формального. Если даже мы изменим формальный параметр значения внутри тела функции, то его фактический собрат останется тем же.
```
#include <iostream>

int f(int n) {
    int res = 1;
    for (int i=1;i<=n;i++) {
        res = res * i;
    }
    return res;
}

int main() {
    int n = 5;
    std::cout << f(n) << std::endl;
    return 0;
}
```
2. По адресу: Производится через параметр указателя, в который передаётся не значение, а адрес фактического параметра. При такой передаче если поменяется значение формального параметра в теле функции, то и значение фактического тоже изменится.
```
#include <iostream>

void f(int n, int *res) {
    *res = 1;
    for (int i=1;i<=n;i++) {
        *res = *res * i;
    }
}

int main() {
    int n = 5, res = 0;
    f(n, &res);
    std::cout << res << std::endl;
    return 0;
}
```
3. По ссылке: Ссылочный параметр также является ещё одним именем фактического.
   **Пример**: дан пятиугольник. Написать программу, которая находит площадь пятиугольника, используя функцию вычисления площади треугольника по трём сторонам.
   ![[Drawing 2025-03-17 01.44.52.excalidraw]]
```
#include <iostream>

void geron(double a, double b, double c, double &dest) {
    double p = (a + b + c) / 2;
    dest = sqrt(p*(p-a)*(p-b)*(p-c));
}

int main() {
    double a, b, c, d, e, d1, d2, s, s1, s2, s3;
    std::cout << "Set a, b, c, d, e, d1, d2:" << std::endl;
    std::cin >> a >> b >> c >> d >> e >> d1 >> d2;
    geron(e, a, d1, s1);
    geron(d1, b, d2, s2);
    geron(d2, c, d, s3);
    s = s1 + s2 + s3;
    std::cout << "s = " << s << std::endl;
    return 0;
}
```

##### Передача массивов в качестве параметров

**Одномерные массивы** передаются в функцию через указатель, т.к. массивная переменная даже в случае статического массива является неявным указателем на первый элемент, но количество элементов массива в функции будет неизвестно, поэтому ещё одним параметром должен идти размер массива.
Пример: code4.cpp

**Двумерные статические массивы** можно также передать через указатель, но при этом внутри функции он будет выглядеть как одномерный, а значит номер элемента массива, зная индексы i j можно пересчитать по формуле $i*n2+j$.  
Пример: code5.cpp

С **динамическими массивами** всё работает на прямую: одномерный - через указатель, двумерный - через двойной указатель.

##### Перегрузка функций

**Перегрузка** - механизм, позволяющий разным функциям (операциям) присваивать одно и то же имя.

**Перегрузка функций** - описание двух и более функций с одним и тем же именем, но с различным по типу или(и) количеству набором параметров.
Пример: code6.cpp

##### Рекурсивные функции

Любую функцию можно вызвать не только внутри функции main(), но и в любой другой функции, описанной ниже. Отдельный интерес это вызов функции внутри самой себя.

По идее рекурсивная функция будет бесконечно вызывать сама себя, однако на практике через некоторое время работы возникает ошибка "Переполнение стэка". Дело в том, что при вызове функции необходимо знать куда именно, на какую команду требуется вернуться. Механизм возврата использует структуру данных "Стэк" - линейный список работающий по принципу LIFO (Last in - first out). В стэк при каждом вызове функции укладывается адрес возврата и значения некоторых переменных окружения. Таким образом наверху стэка всегда находится адрес возврата из последней вызванной функции. Если ни одна функция не заканчивает свою работу, через некоторое время стек переполняется.

Чтобы переполнения не возникало в рекурсивных функция можно завести параметр, значение которого будет меняться, пока не достигнет некоторого предела, на котором рекурсивный вызов прекратится.

##### Параметры по умолчанию

В заголовке функции некоторые параметры можно сразу проинициализировать. Такие параметры называются параметрами по умолчанию при вызове их можно опустить, тогда они примут значение, указанное в заголовке функции.

Имеется несколько правил:
- Параметры по умолчанию должны быть в описании последними.
- Если при вызове опускается один параметр, то должны быть опущены и все следующие за ним.

##### Заголовочный файл

Эти файлы первоначально имели расширение .h (англ. header). В заголовочных файлах обычно указывают лишь заголовки всех функций в библиотеке, а определение функции выносится в ещё один файл с расширением .cpp. Если заголовочный файл находится в системной папке, то он подключается директивой `#include` через угловые скобки, а если в текущем каталоге, то через двойные кавычки.